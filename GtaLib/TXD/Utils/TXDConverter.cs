using System;
using System.Collections.Generic;

using RenderWareLib.SectionsData.TXD;

namespace GtaLib.TXD.Utils
{
    public class TXDConverter
    {
        public ITXDConverterCompressor Compressor { get; set; }

        public TXDConverter()
        {

        }

        public bool Convert(TXDTexture from, TXDTexture to, out List<TXDTextureMipMapData> outputMipMaps)
        {
            outputMipMaps = new List<TXDTextureMipMapData>();
            if (!CanConvert(from, to))
            {
                return false;
            }
            TXDTextureMipMapData[] data = from.GetMipLevelsData();
            for (int i = 0; i < data.Length; i += 1)
            {
                TXDTextureMipMapData mip = data[i];

                TXDCompression fromCompr = from.Compression;
                TXDCompression toCompr = to.Compression;

                TXDRasterFormat intermediateFormat = from.RasterFormat;
                TXDRasterFormat outFormat = to.RasterFormat;

                byte[] intermediateData = mip.RasterData;

                byte[] outData = new byte[0];

                // If compressed, decompress into an intermediate format (R8G8B8A8)
                if (fromCompr == TXDCompression.DXT1 || fromCompr == TXDCompression.DXT3)
                {
                    if (Compressor == null)
                    {
                        throw new TXDConverterException("An DXTn (de-)compressor is not initializated in TXDConverter class.");
                    }
                    intermediateData = Compressor.Decompress(intermediateData, mip.Width, mip.Height, fromCompr);
                }
                // For DXT compression, we need R8G8B8A8. If the input data was already compressed, this
                // intermediate format was already generated by decompression. Otherwise, we have to to it in the
                // raster conversion loop, so we just set the out format to R8G8B8A8.
                if (toCompr == TXDCompression.DXT1 || toCompr == TXDCompression.DXT3)
                {
                    outFormat = TXDRasterFormat.RasterFormatR8G8B8A8;
                    if (intermediateFormat != outFormat)
                    {
                        // outData = new byte[mip.Width * mip.Height * 4];
                    }
                }
                bool pal4 = false;
                bool pal8 = false;

                if ((intermediateFormat & TXDRasterFormat.RasterFormatEXTPAL4) != 0)
                {
                    pal4 = true;
                }
                else if ((intermediateFormat & TXDRasterFormat.RasterFormatEXTPAL8) != 0)
                {
                    pal8 = true;
                }

                if (intermediateFormat != outFormat)
                {
                    // Get specifics of the intermediate raster format
                    uint rm, gm, bm, am; // Masks to extract the various colors from a pixel
                    uint r_s, g_s, b_s, a_s; // Right-shift value to get the actual value from extracted color data.
                    byte rMax, gMax, bMax, aMax; // Maximum values for the colors
                    byte bpp; // BYTES per pixel
                    GetFormatSpecifics(intermediateFormat, out rm, out gm, out bm, out am, out r_s, out g_s, out b_s, out a_s, out rMax, out gMax, out bMax, out aMax, out bpp);

                    // Get specifics of the output raster format
                    uint orm, ogm, obm, oam;
                    uint ors, ogs, obs, oas;
                    byte orMax, ogMax, obMax, oaMax;
                    byte obpp;
                    GetFormatSpecifics(outFormat, out orm, out ogm, out obm, out oam, out ors, out ogs, out obs, out oas, out orMax, out ogMax, out obMax, out oaMax, out obpp);

                    int outCombinedMask = (int)rm | (int)gm | (int)bm | (int)am;

                    bool alpha = from.IsAlphaChannelUsed();

                    int readPosition = 0;
                    int writePosition = 0;

                    List<byte> outputData = new List<byte>();
                    // Convert the raster pixel by pixel
                    for (short y = 0; y < mip.Height; y++)
                    {
                        for (short x = 0; x < mip.Width; x++)
                        {
                            byte r = 0, g = 0, b = 0, a = 0;
                            if (bpp == 4)
                            {
                                uint pixel = BitConverter.ToUInt32(intermediateData, readPosition);
                                readPosition += 4;

                                r = (byte)((pixel & (int)rm) >> (int)r_s);
                                g = (byte)((pixel & (int)gm) >> (int)g_s);
                                b = (byte)((pixel & (int)bm) >> (int)b_s);
                                a = (byte)((pixel & (int)am) >> (int)a_s);
                            }
                            else if (bpp == 2)
                            {
                                ushort pixel = BitConverter.ToUInt16(intermediateData, readPosition);
                                readPosition += 2;

                                r = (byte)((pixel & rm) >> (int)r_s);
                                g = (byte)((pixel & gm) >> (int)g_s);
                                b = (byte)((pixel & bm) >> (int)b_s);
                                a = (byte)((pixel & am) >> (int)a_s);
                            }
                            else if (bpp == 1)
                            {
                                if (pal4 || pal8)
                                {
                                    byte idx = intermediateData[readPosition];
                                    readPosition += 1;
                                    uint pixel = 0;

                                    if (pal4)
                                    {
                                        pixel = BitConverter.ToUInt32(from.Palette, (idx & 0xF) * 4);
                                    }
                                    else if (pal8)
                                    {
                                        pixel = BitConverter.ToUInt32(from.Palette, idx * 4);
                                    }

                                    r = (byte)((pixel & rm) >> (int)r_s);
                                    g = (byte)((pixel & gm) >> (int)g_s);
                                    b = (byte)((pixel & bm) >> (int)b_s);
                                    a = (byte)((pixel & am) >> (int)a_s);
                                }
                                else
                                {
                                    byte pixel = intermediateData[readPosition];
                                    readPosition += 1;

                                    r = (byte)((pixel & rm) >> (int)r_s);
                                    g = (byte)((pixel & gm) >> (int)g_s);
                                    b = (byte)((pixel & bm) >> (int)b_s);
                                    a = (byte)((pixel & am) >> (int)a_s);
                                }
                            }

                            byte modR = (byte)Math.Floor(((r * orMax) / (float)rMax + 0.5f));
                            byte modG = (byte)Math.Floor((g * ogMax) / (float)gMax + 0.5f);
                            byte modB = (byte)Math.Floor((b * obMax) / (float)bMax + 0.5f);
                            byte modA;

                            if (alpha && aMax != 0)
                                modA = (byte)Math.Floor((a * oaMax) / (float)aMax + 0.5f);
                            else
                                modA = oaMax;

                            if (obpp == 4)
                            {
                                uint outPixel = 0;
                                outPixel |= (((uint)modR) << (int)ors);
                                outPixel |= (((uint)modG) << (int)ogs);
                                outPixel |= (((uint)modB) << (int)obs);
                                outPixel |= (((uint)modA) << (int)oas);

                                byte[] rgba = BitConverter.GetBytes(outPixel);
                                outputData.AddRange(rgba);
                                writePosition += 4;
                            }
                            else if (obpp == 2)
                            {
                                ushort outPixel = 0;
                                // uint16_t & outPixel = *((uint16_t*)outDataPtr);
                                outPixel |= (ushort)(((ushort)modR) << (int)ors);
                                outPixel |= (ushort)(((ushort)modG) << (int)ogs);
                                outPixel |= (ushort)(((ushort)modB) << (int)obs);
                                outPixel |= (ushort)(((ushort)modA) << (int)oas);

                                byte[] pixelData = BitConverter.GetBytes(outPixel);
                                outputData.AddRange(pixelData);
                                writePosition += 2;
                            }
                        }
                    }
                    outData = outputData.ToArray();
                }
                else
                {
                    outData = intermediateData;
                }
                if (toCompr == TXDCompression.DXT1 || toCompr == TXDCompression.DXT3)
                {
                    outData = Compressor.Compress(outData, mip.Width, mip.Height, toCompr);
                }
                outputMipMaps.Add(new TXDTextureMipMapData() {
                    Width = mip.Width,
                    Height = mip.Height,
                    RasterData = outData,
                    RasterSize = (uint)outData.Length,
                });
            }
            return true;
        }

        public bool CanConvert(TXDTexture fromTexture, TXDTexture toTexture)
        {
            bool rasterFormatChanged = (fromTexture.RasterFormat != toTexture.RasterFormat);
            bool sizeChanged = (fromTexture.Width != toTexture.Width) || (fromTexture.Height != toTexture.Height);
            bool comprChanged = (fromTexture.Compression != toTexture.Compression);
            bool mipmapCountChanged = (fromTexture.MipMapCount != toTexture.MipMapCount);

            if (sizeChanged)
            {
                return false;
            }
            // Mipmap generation is not supported, but removing mipmaps will work.
            if (toTexture.MipMapCount > fromTexture.MipMapCount)
            {
                return false;
            }
            // Check if the operation is supported
            TXDCompression fromCompr = fromTexture.Compression;
            TXDCompression toCompr = toTexture.Compression;

            if (fromCompr == TXDCompression.DXT1 ||
                fromCompr == TXDCompression.DXT3 ||
                toCompr == TXDCompression.DXT1 ||
                toCompr == TXDCompression.DXT3)
            {
                if (Compressor != null)
                {
                    if (toTexture.Width % 4 != 0 || toTexture.Height % 4 != 0)
                    {
                        return false;
                    }
                }
                else
                {
                    if (rasterFormatChanged || sizeChanged || comprChanged || mipmapCountChanged)
                    {
                        return false;
                    }
                }
            }
            else
            {
                if (toTexture.RasterFormat == TXDRasterFormat.RasterFormatDefault)
                {
                    // Makes no sense for uncompressed textures
                    return false;
                }
            }
            if ((toTexture.GetRasterFormatExtension() & TXDRasterFormat.RasterFormatEXTPAL4) != 0 ||
                (toTexture.GetRasterFormatExtension() & TXDRasterFormat.RasterFormatEXTPAL4) != 0)
            {
                if (fromTexture.RasterFormat != toTexture.RasterFormat || fromCompr != toCompr)
                {
                    return false;
                }
            }
            return true;
        }

        public void GetFormatSpecifics(
            TXDRasterFormat rasterFormat,
            out uint rm,
            out uint gm,
            out uint bm,
            out uint am,
            out uint r_s,
            out uint g_s,
            out uint b_s,
            out uint a_s,
            out byte rMax,
            out byte gMax,
            out byte bMax,
            out byte aMax,
            out byte bpp)
        {
            rm = gm = bm = am = r_s = g_s = b_s = a_s = 0;
            rMax = gMax = bMax = aMax = 0;
            bpp = 0;

            if ((rasterFormat & TXDRasterFormat.RasterFormatEXTPAL4) != 0
                    || (rasterFormat & TXDRasterFormat.RasterFormatEXTPAL8) != 0
            )
            {
                rm = 0x000000FF;
                gm = 0x0000FF00;
                bm = 0x00FF0000;
                am = 0xFF000000;
                bpp = 1;
            }
            else
            {
                switch (rasterFormat & TXDRasterFormat.RasterFormatMask)
                {
                    case TXDRasterFormat.RasterFormatA1R5G5B5:
                        bm = 0x001F;
                        gm = 0x03E0;
                        rm = 0x7C00;
                        am = 0x8000;
                        bpp = 2;
                        break;
                    case TXDRasterFormat.RasterFormatB8G8R8:
                        am = 0x000000;
                        bm = 0x0000FF;
                        gm = 0x00FF00;
                        rm = 0xFF0000;
                        bpp = 4;
                        break;
                    case TXDRasterFormat.RasterFormatB8G8R8A8:
                        bm = 0x000000FF;
                        gm = 0x0000FF00;
                        rm = 0x00FF0000;
                        am = 0xFF000000;
                        bpp = 4;
                        break;
                    case TXDRasterFormat.RasterFormatLUM8:
                        rm = 0xFF;
                        gm = 0xFF;
                        bm = 0xFF;
                        am = 0x00;
                        bpp = 1;
                        break;
                    case TXDRasterFormat.RasterFormatR4G4B4A4:
                        rm = 0x00F0;
                        gm = 0x000F;
                        bm = 0xF000;
                        am = 0x0F00;
                        bpp = 2;
                        break;
                    case TXDRasterFormat.RasterFormatR5G5B5:
                        bm = 0x003E;
                        gm = 0x07C0;
                        rm = 0xF800;
                        am = 0x0000;
                        bpp = 2;
                        break;
                    case TXDRasterFormat.RasterFormatR5G6B5:
                        bm = 0x001F;
                        gm = 0x07E0;
                        rm = 0xF800;
                        am = 0x0000;
                        bpp = 2;
                        break;
                    case TXDRasterFormat.RasterFormatR8G8B8A8:
                        rm = 0x000000FF;
                        gm = 0x0000FF00;
                        bm = 0x00FF0000;
                        am = 0xFF000000;
                        bpp = 4;
                        break;
                }
            }
            r_s = 0;
            g_s = 0;
            b_s = 0;
            a_s = 0;
            for (int i = 0; i < 32; i++)
            {
                if ((rm & (1 << i)) != 0)
                {
                    r_s = (byte)i;
                    break;
                }
            }
            for (int i = 0; i < 32; i++)
            {
                if ((gm & (1 << i)) != 0)
                {
                    g_s = (byte)i;
                    break;
                }
            }
            for (int i = 0; i < 32; i++)
            {
                if ((bm & (1 << i)) != 0)
                {
                    b_s = (byte)i;
                    break;
                }
            }
            for (int i = 0; i < 32; i++)
            {
                if ((am & (1 << i)) != 0)
                {
                    a_s = (byte)i;
                    break;
                }
            }

            rMax = (byte)(rm >> (int)r_s);
            gMax = (byte)(gm >> (int)g_s);
            bMax = (byte)(bm >> (int)b_s);
            aMax = (byte)(am >> (int)a_s);
        }
    }
}
